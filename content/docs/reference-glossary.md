---
id: glossary
title: React की टर्म्स का शब्दकोष
layout: docs
category: Reference
permalink: docs/glossary.html

---

## सिंगल-पृष्ठ एप्लीकेशन {#single-page-application}

सिंगल-पृष्ठ एप्लिकेशन एक ऐसा एप्लिकेशन है जो एक ही HTML पृष्ठ को लोड करता है और उसके साथ सभी आवश्यक एसेट्स (जैसे जावास्क्रिप्ट और css) जो एप्लिकेशन को चलाने के लिए आवश्यक है को भी लोड करता है। पृष्ठ या बाद के पृष्ठों के साथ किसी भी इंटरेक्शन के लिए सर्वर तक राउंड ट्रिप की आवश्यकता नहीं होती है जिसका अर्थ है कि पृष्ठ रीलोड नहीं होता है।

यद्यपि आप React में सिंगल-पृष्ठ एप्लिकेशन का निर्माण कर सकते हैं,पर यह कोई आवश्यकता नहीं है। React का उपयोग मौजूदा वेबसाइटस के छोटे हिस्सों में अतिरिक्त इंट्रक्टिविटी बढ़ाने के लिए भी किया जा सकता है। React में लिखा गया कोड अन्य लाइब्रेरीज के साथ रेंडर किया जा सकता है। React मार्कअप सर्वर रेंडरड लाइब्रेरीज  जैसे की PHP या अन्य क्लाइंट-साइड लाइब्रेरीज के साथ शांतिपूर्वक रेंडर हो सकता है। फेसबुक में React का उपयोग ठीक इसी तरह किया जाता है।

## ES6, ES2015, ES2016, आदि {#es6-es2015-es2016-etc}

ये सभी शब्द ECMAScript लैंग्वेज स्पेसिफिकेशन स्टैंडर्ड के सबसे हाल के वर्शन्स को संदर्भित करते हैं,जावास्क्रिप्ट भाषा इसी का एक कार्यान्वयन है। ES6 वर्शन (जिसे ES2015 के रूप में भी जाना जाता है) में पिछले वर्शन्स के मुकाबले में कई परिवर्धन शामिल किये गए हैं जैसे की: एरो फ़ंक्शंस, क्लासेस, टेम्प्लेट लिटेरल्स, `let` और `const` स्टेटमेंट। आप [यहां](https://en.wikipedia.org/wiki/ECMAScript#Versions) विशिष्ट वर्शन्स के बारे में अधिक जान सकते हैं।

## कम्पाइलर्स {#compilers}

एक जावास्क्रिप्ट कंपाइलर जावास्क्रिप्ट कोड लेता है, और उसे बदल कर एक अलग प्रारूप में जावास्क्रिप्ट कोड देता है। सबसे आम उपयोग ES6 सिंटैक्स लेने और इसे ऊस सिंटैक्स में बदलने का है जिसे कि पुराने ब्राउज़र व्याख्या करने में सक्षम हैं। आमतौर पर React के साथ [Babel](https://babeljs.io/) कंपाइलर का उपयोग किया जाता है।

## बंडलर्स {#bundlers}

बंडलर्स अलग-अलग मॉड्यूल्स के रूप में लिखे गए(अक्सर सैकड़ों में) जावास्क्रिप्ट और css कोड को एक साथ जोड़कर कुछ फाइल्स बनाते है जो की ब्राउज़रों के लिए बेहतर अनुकूलित हैं। आमतौर पर React एप्लिकेशन में उपयोग किए जाने वाले कुछ बंडलों में [Webpack](https://webpack.js.org/) और [Browserify](http://browserify.org/) शामिल हैं।

## Package मैनेजर्स {#package-managers}

Package मैनेजर वे उपकरण हैं जो आपको अपने प्रोजेक्ट में डेपेंडेंसीएस का प्रबंधन करने की अनुमति देते हैं। [npm](https://www.npmjs.com/) और [Yarn](https://yarnpkg.com/) दो package मैनेजर हैं जो आमतौर पर React एप्लिकेशन में उपयोग किए जाते हैं। ये दोनों समान npm package रजिस्ट्री के क्लाइंट हैं।

## CDN {#cdn}

CDN से हमारा मतलब कंटेंट डिलीवरी नेटवर्क है। CDN दुनिया भर में मौजूद सर्वर के नेटवर्क की सहायता से कैश्ड, स्थिर सामग्री वितरित करते हैं।

## JSX {#jsx}

JSX जावास्क्रिप्ट का एक सिंटैक्स एक्सटेंशन है। यह एक टेम्पलेट भाषा के समान है, लेकिन इसमें जावास्क्रिप्ट की पूरी शक्ति है। JSX `React.createElement()` कॉल में कम्पाइल होता है जो सादे जावास्क्रिप्ट ऑब्जेक्ट वापस करता है जिसे "React एलिमेंट्स" कहते हैं। JSX का मूल परिचय प्राप्त करने के लिए [यहां डॉक्स देखें](/docs/introducing-jsx.html) और JSX पर अधिक गहराई से ट्यूटोरियल [यहां](/docs/jsx-in-depth.html) देखें।

React DOM, HTML विशेषता नामों के बजाय कैमलकेस प्रॉपर्टी नेमिंग कन्वेंशन का उपयोग करता है। उदाहरण के लिए, `tabindex` JSX में `tabIndex` बन जाता है। विशेषता `class` को `className` के रूप में भी लिखा जाता है क्योंकि `class` जावास्क्रिप्ट में एक आरक्षित शब्द है:

```js
const name = 'Clementine';
ReactDOM.render(
  <h1 className="hello">My name is {name}!</h1>,
  document.getElementById('root')
);
```  

## [एलिमेंट्स](/docs/rendering-elements.html) {#elements}

React एलिमेंट्स React एप्लीकेशन के निर्माण खंड हैं। एक अधिक व्यापक रूप से ज्ञात अवधारणा "कौम्पोनॅन्ट्स" के साथ एलिमेंट्स को भ्रमित कर सकता है। एक एलिमेंट्स वर्णन करता है कि आप स्क्रीन पर क्या देखना चाहते हैं। React एलिमेंट्स अपरिवर्तनीय हैं।

```js
const element = <h1>Hello, world</h1>;
```

आमतौर पर, एलिमेंट्स का सीधे उपयोग नहीं किया जाता है, लेकिन कौम्पोनॅन्ट्स से वापस किये जाते हैं।

## [कौम्पोनॅन्ट्स](/docs/components-and-props.html) {#components}

React कौम्पोनॅन्ट्स छोटे, पुन: प्रयोज्य टुकड़े हैं जो पृष्ठ पर रेंडर करने के लिए एक React एलिमेंट्स को वापस करते हैं। React कौम्पोनॅन्ट का सबसे सरल संस्करण एक सादे जावास्क्रिप्ट फ़ंक्शन है जो एक React एलिमेंट वापस करता है:

```js
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}
```

कौम्पोनॅन्ट्स ES6 classes भी हो सकते हैं:

```js
class Welcome extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
```

कौम्पोनॅन्ट्स को कार्यक्षमता के अलग-अलग टुकड़ों में विभाजित किया जा सकता है और अन्य कौम्पोनॅन्ट्स के भीतर उपयोग किया जा सकता है। कौम्पोनॅन्ट्स अन्य कौम्पोनॅन्ट्स, arrays, strings और numbers को वापस कर सकते हैं। अंगूठे का एक अच्छा नियम यह है कि यदि आपके UI का एक हिस्सा कई बार उपयोग किया जाता है (बटन, पैनल, अवतार), या अपने आप में पर्याप्त जटिल है (ऐप, फीडस्टोरी, टिप्पणी), तो पुन: प्रयोज्य कौम्पोनॅन्ट होने के लिए यह एक अच्छा उम्मीदवार है । कौम्पोनॅन्ट नाम हमेशा एक कैपिटल लेटर (`<Wrapper/>` **not** `<wrapper/>`) से शुरू होना चाहिए। रेंडरिंग कौम्पोनॅन्ट्स के बारे में अधिक जानकारी के लिए [यह दस्तावेज़](/docs/components-and-props.html#rendering-a-component) देखें।

### [`props`](/docs/components-and-props.html) {#props}

`props` एक React कौम्पोनॅन्ट के लिए इनपुट हैं। वे डेटा हैं जो मूल कौम्पोनॅन्ट से चाइल्ड कौम्पोनॅन्ट तक जाते हैं।

याद रखें कि `props` को सिर्फ रीड ओनली हैं। उन्हें किसी भी तरह से संशोधित नहीं किया जाना चाहिए:

```js
// Wrong!
props.number = 42;
```

यदि आपको यूजर इनपुट या नेटवर्क रिस्पांस के जवाब में कुछ वैल्यू को बदलने की आवश्यकता है, तो इसके बजाय `state` का उपयोग करें।

### `props.children` {#propschildren}

`props.children` हर कौम्पोनॅन्ट पर उपलब्ध है। इसमें किसी कौम्पोनॅन्ट के खुलने और बंद होने के टैग्स के बीच की सामग्री शामिल है। उदाहरण के लिए:

```js
<Welcome>Hello world!</Welcome>
```

String `Hello world!` `Welcome` कौम्पोनॅन्ट में `props.children` में उपलब्ध है:

```js
function Welcome(props) {
  return <p>{props.children}</p>;
}
```

classes के रूप में परिभाषित कौम्पोनॅन्ट्स के लिए, `this.props.children` का उपयोग करें:

```js
class Welcome extends React.Component {
  render() {
    return <p>{this.props.children}</p>;
  }
}
```

### [`state`](/docs/state-and-lifecycle.html#adding-local-state-to-a-class) {#state}

एक कौम्पोनॅन्ट को `state` की आवश्यकता तब होती है जब उस कौम्पोनॅन्ट का डेटा कभी बदलता है। उदाहरण के लिए, एक `Checkbox` कौम्पोनॅन्ट को अपने state में `isChecked` की आवश्यकता हो सकती है, और एक `NewsFeed` कौम्पोनॅन्ट अपने state में `fetchedPosts` का ट्रैक रखना चाह सकता है।

`state` और `props` के बीच सबसे महत्वपूर्ण अंतर यह है कि `props` को पैरेंट कौम्पोनॅन्ट से पास किया जाता है, लेकिन `state` को कौम्पोनॅन्ट द्वारा ही प्रबंधित किया जाता है। एक कौम्पोनॅन्ट अपने `props` को नहीं बदल सकता है, लेकिन यह अपनी `state` को बदल सकता है।

बदलते डेटा के प्रत्येक विशेष टुकड़े के लिए, केवल एक कौम्पोनॅन्ट होना चाहिए जो उस डेटा का "मालिक" हो और अपने state में रखे। दो अलग-अलग कौम्पोनॅन्ट्स के states को सिंक्रनाइज़ करने का प्रयास न करें। इसके बजाय, इसे उनके निकटतम साझा पूर्वज [में रखे](/docs/lifting-state-up.html), और इसे उन दोनों को props के रूप में पास करें।

## [Lifecycle मेथड्स](/docs/state-and-lifecycle.html#adding-lifecycle-methods-to-a-class) {#lifecycle-methods}

Lifecycle मेथड्स कस्टम कार्यक्षमता हैं जो किसी कौम्पोनॅन्ट के विभिन्न चरणों के दौरान निष्पादित होते हैं। मेथड्स तब उपलब्ध होते हैं जब कौम्पोनॅन्ट उपलब्ध होने के बाद DOM ([माउंटिंग](/docs/react-component.html#mounting)) में सम्मिलित होता हैं, जब कौम्पोनॅन्ट अपडेट करता है, और जब कौम्पोनॅन्ट अनमाउंट हो जाता है या DOM से हटा दिया जाता है।

 ## [Controlled](/docs/forms.html#controlled-components) बनाम [Uncontrolled कौम्पोनॅन्ट](/docs/uncontrolled-components.html)

फॉर्म इनपुट से निपटने के लिए React के दो अलग-अलग दृष्टिकोण हैं। 

एक इनपुट फॉर्म एलिमेंट जिसके वैल्यू React द्वारा नियंत्रित किया जाता है, एक *controlled कौम्पोनॅन्ट* कहते है। जब कोई यूजर एक controlled कौम्पोनॅन्ट में डेटा दर्ज करता है तो एक परिवर्तन ईवेंट हैंडलर चालू हो जाता है और आपका कोड तय करता है कि इनपुट वैध है (अपडेट किए गए मूल्य के साथ पुन: रेंडर करके)। यदि आप फिर से री-रेंडर नहीं करते हैं, तो फार्म एलिमेंट अपरिवर्तित रहेगा।

एक *uncontrolled कौम्पोनॅन्ट* React के बाहर फार्म एलिमेंट्स की तरह काम करता है। जब कोई यूजर किसी फॉर्म फ़ील्ड (एक इनपुट बॉक्स, ड्रॉपडाउन, आदि) में डेटा इनपुट करता है, तो अपडेट की गई जानकारी React के कुछ भी करने की आवश्यकता के बिना परिलक्षित होती है। हालाँकि, इसका अर्थ यह भी है कि आप किसी निश्चित मान के लिए फ़ील्ड को बाध्य नहीं कर सकते।

ज्यादातर मामलों में आपको controlled कौम्पोनॅन्ट्स का उपयोग करना चाहिए।

## [Keys](/docs/lists-and-keys.html) {#keys}

"keys" एक विशेष string विशेषता है जिसे आपको एलिमेंट्स की सारणी बनाते समय शामिल करना होगा। keys React को पहचानने में मदद करती हैं कि कौन से आइटम बदल गए हैं, जोड़े गए हैं या हटा दिए गए हैं। एलिमेंट्स को एक स्थिर पहचान देने के लिए array के अंदर एलिमेंट्स को key दी जानी चाहिए।

Keys को केवल एक ही array में सिबलिंग एलिमेंट्स के बीच अद्वितीय होना चाहिए। उन्हें संपूर्ण एप्लिकेशन या किसी एक कौम्पोनॅन्ट में विशिष्ट होने की आवश्यकता नहीं है।

`Math.random()` की तरह keys को कुछ भी पास मत करो। यह महत्वपूर्ण है कि keys में फिर से रेंडर करने वालों की एक "स्थिर पहचान" हो ताकि React यह निर्धारित कर सके कि आइटम कब जोड़े गए, हटाए गए या फिर से ऑर्डर किए गए। आदर्श रूप से, keys को आपके डेटा से आने वाले अनोखा और स्थिर पहचानकर्ताओं के अनुरूप होना चाहिए, जैसे कि `post.id`.

## [Refs](/docs/refs-and-the-dom.html) {#refs}

React एक विशेष एट्रिब्यूट का समर्थन करता है जिसे आप किसी भी कौम्पोनॅन्ट से जोड़ सकते हैं। `ref` एट्रिब्यूट [`React.createRef()` फ़ंक्शन](/docs/react-api.html#reactcreateref) या कॉलबैक फ़ंक्शन, या string (लेगेसी API में) द्वारा बनाया गया ऑब्जेक्ट हो सकता है। जब `ref` एट्रिब्यूट कॉलबैक फ़ंक्शन होता है, तो फ़ंक्शन अपने आर्ग्यूमेंट के रूप में अंतर्निहित DOM एलिमेंट या class इंस्टेंस आर्ग्यूमेंट्स (एलिमेंट के प्रकार के आधार पर) के रूप में प्राप्त करता है। यह आपको DOM एलिमेंट या कौम्पोनॅन्ट इंस्टेंस तक सीधी पहुँच प्रदान करने की अनुमति देता है।

संयम से refs का प्रयोग करें। यदि आप अक्सर अपने ऐप में "चीजों को बनाने" के लिए refs का उपयोग करते हैं, तो [टॉप-डाउन डेटा प्रवाह](/docs/lifting-state-up.html) के साथ अधिक परिचित होने पर विचार करें।

## [इवेंट्स](/docs/handling-events.html) {#events}

React एलिमेंट्स के साथ इवेंट्स को संभालने से कुछ सिंटैक्टिक अंतर होते हैं:

* React इवेंट हैंडलर्स को लोअरकेस के बजाय कैमकलेस का उपयोग करके नामित किया जाता है।
* JSX के साथ आप एक string के बजाय फंक्शन को हैंडलर के रूप में पास करते हैं।

## [Reconciliation](/docs/reconciliation.html) {#reconciliation}

जब किसी कौम्पोनॅन्ट का props या state में परिवर्तन होता है, तो React पहले से रेंडर किए गए व नए लौटे एलिमेंट की तुलना करके निर्णय करता है कि वास्तविक DOM को अपडेट की आवश्यक है या नहीं। जब वे समान नहीं होते हैं, तो React DOM को अपडेट करता है। इस प्रक्रिया को "reconciliation" कहा जाता है।
