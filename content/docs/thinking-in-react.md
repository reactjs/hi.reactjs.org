---
id: thinking-in-react
title: React में सोचना 
permalink: docs/thinking-in-react.html
redirect_from:
  - 'blog/2013/11/05/thinking-in-react.html'
  - 'docs/thinking-in-react-zh-CN.html'
prev: composition-vs-inheritance.html
---

हमारी राय में, जावास्क्रिप्ट द्वारा, बड़ी और तेज़ वेब एप्पस बनाने का React एक मुख्य तरीका है। यह हमारे लिए Facebook और Instagram के लिए काफी अच्छे से बढ़ा है।

कई में से एक मुख्य बात React की है कि कैसे यह आपको एप्प बनाते हुए उसके बारे में सोचने पर मजबूर करता है। इस डॉक्यूमेंट में हम React से बने सर्चएब्ल प्रोडक्ट डाटा टेबल को बनाने की विचार प्रक्रिया पर ध्यान देंगे।

## मॉक के साथ शुरुवात {#start-with-a-mock}

कल्पना कीजिये कि हमारे पास पहले से JSON API और हमारे डिज़ाइनर से एक मॉक उपलब्ध है। मॉक ऐसा कुछ दिखता है:

![Mockup](../images/blog/thinking-in-react-mock.png)

हमारी JSON API कुछ ऐसा डाटा वापस भेजेगी:

```
[
  {category: "Sporting Goods", price: "$49.99", stocked: true, name: "Football"},
  {category: "Sporting Goods", price: "$9.99", stocked: true, name: "Baseball"},
  {category: "Sporting Goods", price: "$29.99", stocked: false, name: "Basketball"},
  {category: "Electronics", price: "$99.99", stocked: true, name: "iPod Touch"},
  {category: "Electronics", price: "$399.99", stocked: false, name: "iPhone 5"},
  {category: "Electronics", price: "$199.99", stocked: true, name: "Nexus 7"}
];
```

## स्टेप 1 : UI को कौम्पोनॅन्ट हायरार्की में ब्रेक करें {#step-1-break-the-ui-into-a-component-hierarchy}

पहली चीज़ जो आप करना चाहेंगे, वह होगी कि अपने हर मॉक कौम्पोनॅन्ट (और उप कौम्पोनॅन्ट) के आस पास बक्से बना दे और सब को नाम दे दें। अगर आप डिज़ाइनर के साथ काम कर रहे है, तो उन्होंने यह काम पहले ही कर रखा होगा, उनसे बात कीजिये! उनकी Photoshop लेयर के नाम, आपके React कौम्पोनॅन्ट के नाम हो सकते है।

परन्तु आप को कैसे पता चलेगा कि खुद का कौम्पोनॅन्ट क्या होना चाहिए? वह ही तकनीक का इस्तेमाल कीजिये जो आप एक नया ऑब्जेक्ट या फंक्शन बनाने के निर्णय के लिए लेते है। एक ऐसी तकनीक है [single responsibility principle](https://en.wikipedia.org/wiki/Single_responsibility_principle), अर्थात्, कौम्पोनॅन्ट को आदर्श रूप में एक ही चीज़ करना चाहिए। अगर वह बढ़ रहा है, तो उसे छोटे उप कौम्पोनॅन्टस में तोड़ देना चाहिए।

चुकी आप अक्सर उपभोक्ता को JSON डाटा मॉडल दिखाते है, आप ये देखेंगे की यदि आपका मॉडल सही बना है, तो आपका UI (और इसलिए आपका कौम्पोनॅन्ट ढांचा) सही दिखेगा। यह इसलिए क्युकी UI और डाटा मॉडल समान *इनफार्मेशन आर्किटेक्चर* इस्तेमाल करते है। अपने UI कौम्पोनॅन्ट को बाँट दीजिये, ताकि हर एक कौम्पोनॅन्ट आपके डाटा मॉडल के टुकड़े से मेल खाए।

![कौम्पोनॅन्ट डायग्राम](../images/blog/thinking-in-react-components.png)

आप देखेंगे कि हमारे एप्प में पांच कौम्पोनॅन्ट है। कौम्पोनॅन्ट द्वारा प्रदर्शित डाटा को हमने इटैलिकस कर रखा है।

  1. **`FilterableProductTable` (नारंगी):** उदाहरण का सम्पूर्णता शामिल
  2. **`SearchBar` (नीला):** सभी *उपभोक्ता इनपुट* को लेता है
  3. **`ProductTable` (हरा):** *यूजर इनपुट* के आधार पर *डाटा कलेक्शन* को प्रदर्शित और फ़िल्टर करता है
  4. **`ProductCategoryRow` (तुरकोईस):** हर *श्रेणी* के शीर्षक का प्रदर्शन
  5. **`ProductRow` (लाल):** हर *प्रोडक्ट* की पंक्ति का प्रदर्शन

अगर आप `ProductTable` पर नज़र डालेंगे, तो आप देखेंगे कि टेबल हैडर ("Name" और "Price" नाम युक्त) अपना खुद का कौम्पोनॅन्ट नहीं है। यह पसंद पर निर्भर करता है और कैसे रखना है, यह चर्चा का विषय है। उदाहरण के तौर पर, हमने इसे `ProductTable` का ही भाग रखा है क्युकी यह *डाटा समूह* कि रेंडरिंग का भाग है, जो कि `ProductTable` की जिम्मेदारी है। मगर, यदि यह हैडर कठिन बनता जाता है (उदहारण के तौर पर, उसमे श्रेणीकरण की संभावना जोड़ना), तो उसका अपना खुद का कौम्पोनॅन्ट, `ProductTableHeader`, बनाना उचित होगा।

अब जब हमे अपने मॉक कौम्पोनॅन्ट की पहचान हो गई है, उन्हें अब हम हायरार्की में जमाएंगे। मॉक में, जो कौम्पोनॅन्ट दूसरे कौम्पोनॅन्ट के भीतर दिखाई दे रहे है, उन्हें हायरार्की में उनके चाइल्ड की तरह दिखाना होगा:

  * `FilterableProductTable`
    * `SearchBar`
    * `ProductTable`
      * `ProductCategoryRow`
      * `ProductRow`

## स्टेप 2: React में स्थिर वर्शन बनाए {#step-2-build-a-static-version-in-react}

<p data-height="600" data-theme-id="0" data-slug-hash="BwWzwm" data-default-tab="js" data-user="lacker" data-embed-version="2" class="codepen">पेन को देखे <a href="https://codepen.io/gaearon/pen/BwWzwm">React में सोचना: स्टेप 2</a>, <a href="https://codepen.io">कोडपेन </a>पर।</p>
<script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>

अब जब आपके पास कौम्पोनॅन्ट हायरार्की है, अब समय हो गया है की हम एप्प बनाये। सबसे आसान तरीका होगा, जहा ऐसा वर्शन बनाए जो आपका डाटा मॉडल लेगा और UI रेंडर करेगा पर उसमे कोई इंट्रक्टिविटीा नहीं होगी। इन प्रक्रिया को भाग करना श्रेष्ठ रहेगा क्युकी एक स्थिर वर्शन बनाने में लिखना ज्यादा होता है और सोचना कम, और इंट्रक्टिविटी जोड़ने में सोचना ज्यादा होता है, और लिखना कम। क्यों, वह हम देखेंगे।

अपनी एप्प का स्थिर वर्शन, जो आपका डाटा मॉडल रेंडर करेगा, बनाने के लिए आपको ऐसे कौम्पोनॅन्टस बनाने होंगे जो दूसरे कौम्पोनॅन्टस को पुनः उपयोग करे, और डाटा को *props* से दे। *props* पैरेंट से चाइल्ड को डाटा देने का तरीका है। अगर आप *state* कांसेप्ट से परिचित है, तो यह स्थिर वर्शन बनाने के लिए *state* **बिलकुल भी उपयोग न करे**। state सिर्फ इंट्रक्टिविटी के लिए आरक्षित है, मतलब, डाटा जो समय के साथ बदलता है। चुकी यह एप्प का स्थिर वर्शन है, आपको इसकी जरुरत नहीं।

आप ऊपर-से-नीचे या नीचे-से-ऊपर बना सकते है। मतलब, या तो आप अपने कौम्पोनॅन्टस हायरार्की में ऊपर (अर्थात `FilterableProductTable` से शुरुवात) या सबसे नीचे (`ProductRow`) से शुरू कर सकते है। सरल उदाहरण में, बड़े प्रोजेक्ट्स में ऊपर-से-नीचे और टेस्ट लिखना नीचे-से-ऊपर करेंगे तो ज्यादा आसान होगा।

इस स्टेप के अंत तक, आपके पास एक पुनः-प्रयोज्य कौम्पोनॅन्टस की लाइब्रेरी होगी जो डाटा मॉडल रेंडर कर सके। कौम्पोनॅन्ट में सिर्फ `render()` मेथड होगा, चुकी यह एप्प का स्थिर वर्शन है। हायरार्की में शीर्ष वाला कौम्पोनॅन्ट (`FilterableProductTable`) आपका डाटा मॉडल prop की तरह लेगा। यदि आप अपने मुख्य डाटा मॉडल बदलाव कर `ReactDOM.render()` फिर से कॉल करते है, आपका UI अपडेट हो जाएगा। आप देख सकते है की आपका UI कैसे अपडेट होता है और कहा बदलाव करना है। React का **one-way data flow** (जिसे *one-way binding* भी बुला सकते है) सब चीज़ो को मॉड्यूलर और तेज़ रखता है।

अगर आपको इस स्टेप में कोई सहायता चाहिए तो [React docs](/docs/) को देखे।

### संक्षिप्त अन्तराल: Props की तुलना में State {#a-brief-interlude-props-vs-state}

React में दो प्रकार के डाटा "मॉडल" है: props और state। दोनों के अंतर को समझना महत्वपूर्ण है; पढ़िए [React का शासकीय डॉक्यूमेंट](/docs/state-and-lifecycle.html) यदि आपको दोनों के अंतर के बारे में नहीं पता हो तो। देखिये [FAQ: state और props में क्या अंतर है?](/docs/faq-state.html#what-is-the-difference-between-state-and-props)

## स्टेप 3: UI state का न्यूनतम (परन्तु पूर्ण) प्रतिनिधित्व {#step-3-identify-the-minimal-but-complete-representation-of-ui-state}

अपने UI को इंटरैक्टिव बनाने के लिए आपको अपने मुख्य डाटा मॉडल में बदलाव करवाने होंगे। React यह **state** के द्वारा हासिल करता है।

अपनी एप्प सही बनाने के लिए, आपको पहले म्यूटेबल state के न्यूतम सेट के बारे में सोचना होगा जिसकी आपकी एप्प को जरुरत होगी। इसका समाधान [DRY: *Don't Repeat Yourself*](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) है। अपने state के न्यूतम वर्णन के बारे में अंदाज़ा लगाइये जिसकी आपके एप्प को ज़रूरत है और बाकि चीज़ो का हिसाब उसकी मांग पर तय कीजिये। उदाहरण, अगर आप TODO लिस्ट बना रहे है, तो TODO लिस्ट के आइटम को आसपास रखिये; अलग state variable बनाने की आवश्यकता नहीं है। इसकी बजाए, जब TODO आइटम्स की लम्बाई को लें तब ही आप TODO की संख्या को रेंडर करेंगे।

अपने उदाहरण एप्प के सभी डाटा के टुकड़ो के बारे में सोचिये। हमारे पास है: 

  * अपने प्रोडक्ट्स की असली लिस्ट 
  * उपभोक्ता ने जो सर्च टेक्स्ट डाला है 
  * चेकबॉक्स की वैल्यू
  * प्रोडक्ट्स की फ़िल्टर करी हुई लिस्ट 

हर एक को गौर से देखते है और समझते है इनमे से कोनसा state है। हर डाटा के टुकड़ो के बारे में ३ सवाल करें:

  1. क्या यह पैरेंट से props के द्वारा आया? अगर हा, तो यह state नहीं है।
  2. क्या यह वक्त के साथ बदलता नहीं है? अगर हा, तो यह state नहीं है।
  3. क्या आप अपने कौम्पोनॅन्ट के कोई भी दूसरे state या props के जरिये इसका हिसाब लगा सकते है? अगर हा, तो यह state नहीं है।

अपने प्रोडक्ट्स की असली लिस्ट props की तरह आ रही है, तो यह state नहीं है। सर्च टेक्स्ट और चेकबॉक्स state जैसे व्यतीत होते है क्युकी यह समय के साथ बदलते है एवं इसका हिसाब ओर कही से नहीं लगा सकते। आख़िरकार, प्रोडक्ट्स की फ़िल्टर करी हुई लिस्ट state नहीं है क्युकी इसका हिसाब प्रोडक्ट्स की असली लिस्ट और सर्च टेक्स्ट के साथ चेकबॉक्स की वैल्यू से लगा सकते है।

आखिरकार हमारा state होगा:

  * उपभोक्ता ने जो सर्च टेक्स्ट डाला है 
  * चेकबॉक्स की वैल्यू

## स्टेप 4: जानिए आपके state का निवास {#step-4-identify-where-your-state-should-live}

<p data-height="600" data-theme-id="0" data-slug-hash="qPrNQZ" data-default-tab="js" data-user="lacker" data-embed-version="2" class="codepen">पेन को देखे <a href="https://codepen.io/gaearon/pen/qPrNQZ">React में सोचना: स्टेप 4</a>, <a href="https://codepen.io">कोडपेन </a>पर।</p>

ठीक, तो हमने एप्प state का न्यूतम सेट पहचान लिया है। अब, हमे ये पहचानना है की इस state का कोनसा कौम्पोनॅन्ट म्यूटेट होता है या *कोन मालिक है*।

याद रखे: React कौम्पोनॅन्ट हायरार्की के नीचे के बहाव में one-way डाटा के बारे में है। यह शायद एकदम से साफ नहीं होगा की कोनसा कौम्पोनॅन्ट state का मालिक है। **अक्सर यह सबसे ज्यादा चुनौतीपूर्ण भाग होता है अपरिचित लोगो के लिए समझने के लिए**, तो समझने के लिए यह कीजिये: 

अपनी एप्प के हर state के भाग के लिए: 

  * हर उस कौम्पोनॅन्ट को पहचाने जो state के आधार पर कुछ रेंडर करता है।
  * एक कॉमन मुख्य कौम्पोनॅन्ट पहचाने (एकलौता कौम्पोनॅन्ट, सारे कौम्पोनॅन्टस के ऊपर, जिसे state की हायरार्की चाहिए होगी)।
  * या तो कॉमन मुख्या या तो दूसरा कौम्पोनॅन्ट, जो हायरार्की में ऊपर है, state का मालिक होना चाहिए।
  * यदि आप वह कौम्पोनॅन्ट नहीं पहचान पा रहे जो state का मालिक होना चाहिए, एक नया कौम्पोनॅन्ट बनाइये जो सिर्फ state रखेगा और उसे हायरार्की में कही कॉमन मुख्य कौम्पोनॅन्ट के ऊपर रख दीजिये।

अपनी एप्प की रणनीति के बारे में देखते है:

  * `ProductTable` को state के आधार पर प्रोडक्ट लिस्ट फ़िल्टर करना है ओर `SearchBar` को खोजने वाला टेक्स्ट ओर चुना हुआ state बताना है।
  * `FilterableProductTable` एक कॉमन मालिक कॉम्पोनेन्ट होगा।
  * फ़िल्टर टेक्स्ट और चुनी हुई वैल्यू को `FilterableProductTable` में रखना सही होगा।

हमने अपने state को `FilterableProductTable` में रखने का निर्णय लिया है। सबसे पहले, एक इंस्टैंस प्रॉपर्टी ऐड करे `this.state = {filterText: '', inStockOnly: false}` अपने `FilterableProductTable` के `constructor` में, अपना प्रारंभिक state बनाने के लिए। फिर `filterText` और `inStockOnly` को `ProductTable` और `SearchBar` में props की तरह दीजिये। आखिरकार, इन props को इस्तेमाल करके `ProductTable` की रौ को फ़िल्टर करे और `SearchBar` में फॉर्म फील्ड की वैल्यू सेट करे।

आप अपनी एप्प का व्यव्हार देख सकते है: `filterText` को `"ball"` वैल्यू दीजिये और अपनी एप्प रिफ्रेश कीजिये। आप देखेंगे की टेबल का डाटा सही से बदलेगा।

## स्टेप 5: उल्टा डाटा बहाव जोड़ना {#step-5-add-inverse-data-flow}

<p data-height="600" data-theme-id="0" data-slug-hash="LzWZvb" data-default-tab="js,result" data-user="rohan10" data-embed-version="2" data-pen-title="Thinking In React: Step 5" class="codepen">पेन को देखे <a href="https://codepen.io/gaearon/pen/LzWZvb">React में सोचना: स्टेप 5</a>, <a href="https://codepen.io">कोडपेन </a>पर।</p>

अब तक हमने ऐसी एप्प बना ली जो हायरार्की से नीचे जाते हुए props और state से रेंडर सही से करती है। अब समय है डाटा के उलटे बहाव का: फॉर्म कॉम्पोनेन्ट के हायरार्की में `FilterableProductTable` का state अपडेट होना चाहिए।

React डाटा फ्लो स्पष्ट करता है, जो आपको ये समझने में सहायता करेगा की आपका प्रोग्राम काम कैसे करता है, पर इसमें परंपरागत two-way डाटा binding से ज्यादा लिखना होगा।

अगर आप इस उदाहरण में कुछ लिखने का या चेकबॉक्स को चुन ने की कोशिश करेंगे, आप देखेंगे की React आपके इनपुट को नज़र अंदाज़ कर रहा है। यह जान बूझकर किया गया है, क्युकी हमने `input` का `value` prop हमेशा `FilterableProductTable` में पास किये हुए `state` के बराबर रखा है। 

अब हम सोचते है की हम क्या चाहते है। हम चाहते है की जब भी उपभोक्ता फॉर्म में बदलाव करे, हमारा state भी इनपुट जैसा ही बदले। चुकी कौम्पोनॅन्टस को अपना खुद का ही state बदलना चाहिए, `FilterableProductTable` `SearchBar` को कालबैक देगा, जो state के बदलने पर ही दिखेगा। हम `onChange` इवेंट का प्रयोग इनपुट पर कर सकते है। जो `FilterableProductTable` से पास किया हुआ कालबैक है, वह `setState()` को कॉल करेगा ओर एप्प अपडेट हो जाएगी।

## और बस हो गया {#and-thats-it}

उम्मीद है कि इससे आपकी कौम्पोनॅन्ट और React की एप्प बनाने कि सोच को योजना मिली होगी। जबकि इसमें लिखना ज्यादा है जितने की आपको आदत होगी, याद रखिये कि code को लिखने से ज्यादा पढ़ा जाता है, और ऐसे मॉड्यूलर और स्पष्ट code को पढ़ना कम कठिन होता है। जैसे जैसे आप कौम्पोनॅन्टस की बढ़ी लाइब्रेरी बनानी शुरू करेंगे, आप इस स्पष्टता और मॉड्युलरिटी को सरहाने लगेंगे और code के पुनः उपयोग के चलते आपका code सिकुड़ता जाएगा। :)
